1.全局锁
对整个数据库实例加锁。mysql全局加读锁的命令，flush tables with read lock
典型应用场景，全库逻辑备份。把所有表都select出来存成文本。其他线程的以下语句会被阻塞：
数据的增删改，数据定义语句（建表，修改表结构等），更新类事务语句。
官方自带备份工具mysqldump

全局只读为什么不用set global readonly = true;
在有些系统中，readonly的值会被用来做其他逻辑，比如用来判断一个库是主库还是从库。因此修改global变量的方式影响面更大
在异常处理机制上有差异。如果执行Flush tables with read lock命令之后由于客户端发生异常断开，那么MySQL会自动释放这个全局锁，整个库回到可以正常更新的状态。
而将整个库设置为readonly之后，如果客户端发生异常，则数据库会一直保持readonly状态，这样会导致整个库长时间处于不可写状态，风险较高

2.表级锁（表锁和元数据锁（meta data lock MDL））
lock tables tablename read/write；可以用unlock tables主动释放，客户端断开后也会自动释放。
锁不仅限制了别的线程，也限制了本线程的操作。例如
线程A 执行 lock tables t1 read, t2 write;其他线程读t1，读写t2都会被阻塞。同时，A在unlock tables之前，也只能执行读t1，读写t2的操作，不可以写t1。

另外一个级别的锁，MDL不需要显示的使用，在访问一个表的时候会自动加上，作用时保证读写的正确性。
当对一个表增删改查时自动加MDL读锁，对表结构修改时，加MDL写锁。

注意事项：
读锁之间不互斥。即可能有多个线程对一个表进行读操作。
事务中的MDL锁不会在语句执行完后释放，而是在事务提交后释放。
3.行级锁

