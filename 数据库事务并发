1.数据库隔离级别
数据库可能存在的三个问题
脏读：事务B读取事务A还没有提交的数据。
不可重复读：两次事务读取的数据不一致。
幻度：事务A修改了数据，B也修改了数据，在A看来，修改了数据却不一致。
在多事务并发的情况下讨论
第一级：读未提交 read uncommitted，在此级别会发生脏读。

第二级：读提交 read committed 禁止读取其他事务已经修改但未提交的数据。SQL Sever， Oracle的默认级别。
singo拿着工资卡去消费，系统读取到卡里确实有2000元，而此时她的老婆也正好在网上转账，把singo工资卡的2000元转到另一账户，并在singo之前提交了事务，
当singo扣款时，系统检查到singo的工资卡已经没有钱，扣款失败，singo十分纳闷，明明卡里有钱，为何…
出现上述情况，即我们所说的不可重复读，两个并发的事务，“事务A：singo消费”、“事务B：singo的老婆网上转账”，事务A事先读取了数据，事务B紧接了更新了数据，
并提交了事务，而事务A再次读取该数据时，数据已经发生了改变。
第二级读提交可以解决脏读的问题，但是无法解决不可重复读的问题。

第三级：重复读。当前事务提交前，其他事务不可修改或删除当前事务已经读取的数据。
（singo一旦开始了消费事务，老婆就不能对信用卡的数据进行修改。）

无法解决：singo的老婆工作在银行部门，她时常通过银行内部系统查看singo的信用卡消费记录。
有一天，她正在查询到singo当月信用卡的总消费金额（select sum(amount) from transaction where month = 本月）为80元，
而singo此时正好在外面胡吃海塞后在收银台买单，消费1000元，即新增了一条1000元的消费记录（insert transaction … ），并提交了事务，
随后singo的老婆将singo当月信用卡消费的明细打印到A4纸上，却发现消费总额为1080元，singo的老婆很诧异，以为出现了幻觉，幻读就这样产生了。
Mysql的隔离级别就是重复读。
第四级：序列化 serializable
可以解决幻读，但是性能低，花费高，事务顺序执行。在事务完成前，不能向事务读取的范围插入新行。
